[{"content":"Description You are given two strings s1 and s2 of equal length consisting of letters \u0026quot;x\u0026quot; and \u0026quot;y\u0026quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].\nReturn the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.\nIntuition Given a index i, there are totally 4 possiblilities of s1[i] and s2[i]: x-x,y-y,x-yandy-x. x-x and y-y have been matched, we just need to process two other situations.\nAlgorithm Assum there are a pairs of x-y and b pairs of y-x. For 2 pairs of x-y or y-x, we can swap 1 steps to make them matching: \u0026quot;xx\u0026quot;|\u0026quot;yy\u0026quot;$\\rightarrow$\u0026quot;xy\u0026quot;|\u0026quot;xy\u0026quot;. For one x-y and one y-x, we need 2 steps: \u0026quot;xy\u0026quot;|\u0026quot;yx\u0026quot;$\\rightarrow$\u0026quot;xx\u0026quot;|\u0026quot;yy\u0026quot;$\\rightarrow$\u0026quot;xy\u0026quot;|\u0026quot;xy\u0026quot;.\nSo, if a and b are both even. We just need $\\frac{a+b}{2}$ steps without other process.\nIf one of a and b is even and the other is odd, we can\u0026rsquo;t make it match any way.\nIf their are both odd, we need $\\frac{a+b-2}{2}+2=\\frac{a+b}{2}+1$ steps.\nPseudocode  Read s1 and s2 to get a and b.\nIf only one of a and b is even, return -1.\nElse if both a and b are even, return $\\frac{a+b}{2}$.\nElse return $\\frac{a+b}{2}+1$\n Code class Solution: def minimumSwap(self, s1: str, s2: str) -\u0026gt; int: a = 0 b = 0 for i in range(len(s1)): if s1[i] == \u0026#39;x\u0026#39; and s2[i] == \u0026#39;y\u0026#39;: a += 1 elif s1[i] == \u0026#39;y\u0026#39; and s2[i] == \u0026#39;x\u0026#39;: b += 1 if a%2==0 and b%2==0: return int((a+b)/2) elif a%2==1 and b%2==1: return int((a+b)/2+1) else: return -1 Complexity Analysis  Time complexity: $O(n)$. Space complexity: $O(1)$.  ","permalink":"https://guangchen811.github.io/leetcode/minimumswapstomakestringsequal/","summary":"No.1247","title":"Minimum Swaps to Make Strings Equal"},{"content":"Description You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node\u0026rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nIntuition There are only two possibilities when we searching a node:\n node is equal to the value node is not equal to the value  Algorithm When the node is equal to the value, we just need to return it. Otherwise, we just need to visit its left or right child recursively.\nPseudocode  visit root node.\n If root is null or root\u0026rsquo;s value is equal to target value, return the root.\nOtherwises, if root\u0026rsquo;s value is bigger than target value.\n visit root\u0026rsquo;s left child.\n Otherwises\n visit root\u0026rsquo;s right child.\n   Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def searchBST(self, root: Optional[TreeNode], val: int) -\u0026gt; Optional[TreeNode]: if (root == None or root.val == val): return root elif root.val \u0026lt; val: return self.searchBST(root.right, val) else: return self.searchBST(root.left, val) Complexity Analysis  Time complexity: $O(\\log{n})$ Space complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/searchinabinarysearchtree/","summary":"No.700","title":"Search in a Binary Seaerch Tree"},{"content":"Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nIntuition Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\nAlgorithm Just like how we would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of $l1$ and $l2$. Since each digit is in the range of 0\u0026hellip;9, summing two digits may \u0026ldquo;overflow\u0026rdquo;. For example $5+7=12$. In this case, we set the current digit to 2 and bring over the $carry=1$ to the next iteration. $carry$ must be either $0$ or $1$ because the largest possible sum of two digits (including the carry) is $9+9+1=19$.\nPseudocode  Initialize current node to dummy head of the returning list.\nInitialize $carry$ to 0.\nInitialize $p$ and $q$ to head of $l1$ and $l2$ respectively. Loop through lists $l1$ and $l2$ until you reach both ends.\n Set $x$ to node $p$\u0026rsquo;s value. If $p$ has reached the end of $l1$, set to 0.\nSet $y$ to node $q$\u0026rsquo;s value. If $q$ has reached the end of $l2$, set to 0.\nSet $sum=x+y+carry$.\nUpdate $carry = sum/10$\nCreate a new node with teh digit value of ($sum\\mod{10}$) and set it to current node\u0026rsquo;s next, then advance current node to next.\nAdvance both $p$ and $q$.\n Check if $carry=1$, if so append a new node with digit 1 to the returning list.\nReturn dummy head\u0026rsquo;s next node.\n Code # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummyHead = ListNode(val=0) p = l1 q = l2 curr = dummyHead carry = 0 while(p != None or q != None): if p != None: x = p.val else: x = 0 if q != None: y = q.val else: y = 0 sum = carry + x + y carry = sum // 10 curr.next = ListNode(val=sum % 10) curr = curr.next if(p != None): p = p.next if(q != None): q = q.next if (carry \u0026gt; 0): curr.next = ListNode(carry) return dummyHead.next Complexity Analysis   Time complexity: $O(\\max{(m,n)})$. Assume that $m$ and $n$ represents the length of $l1$ and $l2$ respectively, the algorithm above iterates at most $\\max{(m,n)}$ times.\n  Space complexity: $O(\\max{(m,n)})$. The length of the new list is at most $\\max{(m,n)}+1$.\n  ","permalink":"https://guangchen811.github.io/leetcode/addtwonumbers/","summary":"No.2","title":"Add Two Numbers"}]