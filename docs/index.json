[{"content":"After using oh-my-zsh on my macbook for a few days, I feel the original bash theme not elegant enough. Thus, I start searching something like oh-my-zsh for bash, then I found oh my bash.\nOh My Bash is an open source, community-driven framework for managing your bash configuration. Let\u0026rsquo;s get started.\nOh My Bash is installed by running one of the following commands in your terminal.\nvia curl bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmybash/oh-my-bash/master/tools/install.sh)\u0026#34; via wget bash -c \u0026#34;$(wget https://raw.githubusercontent.com/ohmybash/oh-my-bash/master/tools/install.sh -O -)\u0026#34; The above command will execute the following commands line by line.\ngit clone --depth=1 https://github.com/ohmybash/oh-my-bash.git /root/.oh-my-bash mv /root/.bashrc /root/.bashrc.omb-backup-yyyymmddhhmmss #timestamp cp /root/.oh-my-bash/templates/bashrc.osh-template /root/.bashrc mv -f /root/.bashrc.omb-temp /root/.bashrc After the above command, you can see the basic oh-my-bash theme on your terminal.\nthe default theme is font. you can change the variable OSH_THEME in the file ~/.bashrc. All the theme can be found in this link. I\u0026rsquo;d like to use bakke right now.\n","permalink":"https://guangchen811.github.io/install/oh-my-bash/","summary":"After using oh-my-zsh on my macbook for a few days, I feel the original bash theme not elegant enough. Thus, I start searching something like oh-my-zsh for bash, then I found oh my bash.\nOh My Bash is an open source, community-driven framework for managing your bash configuration. Let\u0026rsquo;s get started.\nOh My Bash is installed by running one of the following commands in your terminal.\nvia curl bash -c \u0026#34;$(curl -fsSL https://raw.","title":"Oh My Bash"},{"content":"DGL offical document about customizing GNN layers is here\nDGL provides many message passingfunctions for uses to customize their own GNN layers.\n","permalink":"https://guangchen811.github.io/posts/my-own-gnn-layer/","summary":"DGL offical document about customizing GNN layers is here\nDGL provides many message passingfunctions for uses to customize their own GNN layers.","title":"My Own GNN Layer"},{"content":"This is python offical document that explain the difference between Scope and Namespace.\nMy summary after reading the document is as follows.\nWhat is namespace and scope？ A namespace is a mapping from names to objects. Examples of namespaces are: the set of built-in names(containing functions usch as abs(), and built-in exception names); the global names in a module; and the localnames in a function invocation. In a sense the set of attributes of an object aloso form a namespace.\nThe important thhing to know about namespaces is that there is absolutely norelation between names in dfferent namespaces; for instance, two different modules may both define a function maximize without confusion - users of the modules must prefix it with the module name.\nNamespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits.\nA scope is a textual region of a Python program where a namespace is directly accessible. \u0026ldquo;Directly accessible\u0026rdquo; here means that an unqualified reference to a name attempts to find the name in the namespace.\nAlthough scopes are determined statically, they are used dynamically. At any time during eecution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n the innermost scope, which is searched first, contains the local names the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also non-global names the next-to-last scope contains the current module\u0026rsquo;s global names the outermost scope (searched last) is the namespace containing built-in names  This blog is great: Mastering python namespaces and scopes\n","permalink":"https://guangchen811.github.io/python/namespace/","summary":"This is python offical document that explain the difference between Scope and Namespace.\nMy summary after reading the document is as follows.\nWhat is namespace and scope？ A namespace is a mapping from names to objects. Examples of namespaces are: the set of built-in names(containing functions usch as abs(), and built-in exception names); the global names in a module; and the localnames in a function invocation. In a sense the set of attributes of an object aloso form a namespace.","title":"Namespace and scope"},{"content":"source\n介绍 模块是Go语言管理依赖的方式.\n这篇文档详细地说明了Go语言的模块系统. 关于如何创建Go项目，可以参看如何写Go语言程序. 关于使用模块、将项目迁移到模块，和其他相关的话题，请参看从使用Go模块开始的系列博客.\n模块、包和版本 模块是统一发布、版本控制和分发的包的集合. 我们可以直接从版本控制仓库中下载模块，也可以从一些模块代理服务器下载.\n一个模块可以由go.mod文件中标明的模块路径来识别. 除模块路径外，go.mod 文件中还包含了模块间依赖的信息.模块的根目录为包含go.mod文件的路径. 主模块是指包含go命令被调用的目录的模块.\n模块中的每一个包是指在相同路径下、一同被编译的源文件的集合. 一个包路径是由模块路径和包含包的子目录(指从模块根目录出发的相对路径)拼接而成的. 例如，模块\u0026quot;golang.org/x/net\u0026quot;的\u0026quot;html\u0026quot;路径中包含的包的路径为\u0026quot;golang.org/x/net/html\u0026quot;.\n模块路径 模块路径是指一个模块的标准名称，他会在go.mod文件中使用mod指令声明. 如上文所述，模块路径是模块内包路径的前缀.\n一个模块路径既要指明模块的功能，也要指明我们可以在哪里找到它。一般来说，模块路径会包含仓库根路径、仓库中文件夹的路径(一般为空，这是仓库的根目录就是模块的根路径)，以及一个主版本号后缀(只针对主版本号大于等于2时)。\n 仓库根路径是模块路径中对应版本控制仓库根路径的部分. 大多数模块都定义在其仓库的根路径上。例如仓库根路径golang.org/x/net就是与其同名的模块的根路径。关于go命令如何使用HTTP协议从模块中定位一个仓库请参阅从模块路径中找到仓库. 如果模块没有被定义在仓库的根目录，模块子目录就是模块名称中指明模块在仓库中地址的部分。模块子目录也可以作为前缀指明版本，如模块golang.org/x/tools/gopls就是根路径为golang.org/x/tools/gopls的仓库中的gopls子目录。参看，将版本映射为提交和仓库中的模块路径. 在发布主版本号大于等于2的模块时，模块路径必须以主版本后缀，如/v2结尾。他也可以作为子目录的一部分。例如，路径为golang.org/x/repo/sub/v2的模块可能在仓库golang.org/x/repo的/sub路径中，也可能在/sub/v2路径中.  如果一个模块可能被其他模块依赖，我们只有在遵守上述规则的情况下，go命令才能正确的找到并下载该模块。此外，模块路径中的字符还有一些词法限制。\n版本(version) 版本号表明了模块的一个不可变快照，它可以是发布版或预发布版。每个版本都以字母 v开头，随后是可读的版本信息。有关如何格式化、解释和比较版本的详细信息，请参阅语义版本 2.0.0\n总的来说，一个语义版本包含三个由.分割的非负整数(从左到右分别标识主要版本号、次要版本号和布丁版本号). 补丁版本后面可以跟一个以连字符开头的可选预发布字符串。 预发布字符串或补丁版本后面可以跟以加号开头的构建元数据字符串。 例如，v0.0.0、v1.12.134、v8.0.5-pre 和 v2.0.9+meta 都是有效版本。\n版本的每个部分都表示版本是否稳定以及是否与以前的版本兼容。\n 当一个向后不兼容的改变发生时（如一个包被删除时），主要版本号必须加一，次要版本号和补丁版本号需要置为0. 当一个向后兼容的改变发生时（如增加了一个新的函数），次要版本号需要加一，补丁号需要置为0. 当发生了对模块的对外接口没有变化的改动时（如修复了一个bug或者进行了代码优化），补丁号需要加1. pre-release后缀用于标注预发行版. 预发行版通常先于发行版发布. 例如，v1.2.3-pre要早于v1.2.3. 为了进行版本比较，构建元数据（build metadata）后缀会被忽略. 标有构建元数据的版本会被版本控制仓库忽略，但是构建元数据会被保留在go.mod文件指定的版本中。后缀+incompatible表示发布在迁移到模块主版本号大于等于2的版本之前发行的版本.  如果一个版本的主版本为0或者带有pre后缀，那么该版本是不稳定的. 例如v0.2.0可能并不兼容v0.1.0, v1.5.0-beta可能不兼容v1.5.0.\nGo语言可以通过使用标签、分支和版本重命名来访问不符合上述命名规范的模块. 然而，在主模块中，go命令会自动把不符合标准的名字转换为标准版本号. go命令还会自动删掉构建元数据后缀（除+incompatible之外）。这会导致产生伪版本(pseudo-version)：指一个编码了版本标识或者时间戳的预发行版. 例如go get -d golang.org/x/net@daa7c041将会被转换为v0.0.0-20191109021931-daa7c04131f4. 标准版本被要求放在主模块外。此外，如果非标准的版本如master出现在go.mod文件中，go命令会报错.\n伪版本 一个伪版本特指用于在版本控制仓库中编码特别版本信息的预发行版本. 例如v0.0.0-20191109021931-daa7c04131f5就是一个伪版本.\n伪版本可能用于重命名没有语义版本标签的版本. 主要出现在创建版本标签前的测试提交，如在开发分支中的提交.\n每一个伪版本号由三部分组成：\n 一个基本版本前缀(vX.0.0或X.Y.Z-0)，可以来自于修订前的语义版本标签，如果没有的话就定为vX.0.0. 时间戳(yyyymmddhhmmss),指创建该版本时的世界标准时间(UTC). 在Git中表示提交时间而非创作时间. 一个修订标识符(abcdefabcdef)，为提交哈希的12位前缀. 如果是子版本，则为12个0.  由于基本版本号的不同，伪版本号可能为以下三种形式之一. 这确保了伪版本号一定高于基本版本号，但低于下一个有标签的版本号.\n-vX.0.0-yyyymmddhhmmss-abcdefabcdef被用于基本版本号未知的情况. 与所有版本一样，主版本号必须匹配模块的主版本后缀. -vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef被用于基本版本号为vX.Y.Z-pre的情形. -vX.Y.(Z+1).0.yyyymmddhhmmss-abcdefabcdef被用于主版本号为vX.Y.Z的情况. 例如，如果基本版本号为v1.2.3，伪版本号可能是v1.2.4-0.20191109021931-daa7c04131f5.\n通过使用不同的基本版本号，多个伪版本号可能指向同一次提交. 这种情况在一个低版本在伪版本产生后被打上新标签时会自然的发生。\n这种形式为伪版本提供了两个有用的特性：\n 具有已知基本版本号的伪版本排序高于基本版本但低于其他预发行版本. 基于相同版本的伪版本按时间排序.  go命令会执行以下操作来确保模块作者可以控制伪版本如何与其他版本比较，伪版本是指模块提交历史中的一部分的版本.\n 如果一个基本版本已被指明，那么必须存在一个对应的语义版本标签作为伪版本描述的版本的祖先. 这可以避免开发者绕开最小版本号选择原则，使用一个比所有版本都高的版本，如v1.999.999-99999999999999-daa7c04131f5. 时间戳必须匹配重命名版本的时间戳. 这是为了防止攻击者使用相很多相同版本号淹没模块代理. 同时也防止了模块使用者修改版本的相对顺序. 修订版必须是模块仓库中分支或标签之一的祖先. 这是为了防止攻击者引用未经允许的修改或拉取请求.  伪版本不需要手动输入. 许多命令都会接受提交哈希或者分支名称，并将其自动转化为伪版本号。例如:\ngo get -d example.com/mod@master go list -m -json example.com/mod@abcd1234 Major version suffixes 从主版本2开始，模块路径必须有一个主版本号前缀如/v2来匹配主版本号。例如，一个模块可以将v1.0.0存在example.com/mod路径下，那么它必须在example.com/mod/v2路径存储其v2.0.0版本.\n主版本号后缀需要实现导入兼容性原则：\n 如果一个旧的包和新的包有相同的引用路径，新的包必须向后兼容旧的包。  根据定义，模块新主要版本中的软件包与之前主要版本的相应软件包不向后兼容。因此，从v2开始，软件包需要新的导入路径。这是通过在模块路径中添加一个主要版本后缀来实现的。由于模块路径是模块中每个软件包导入路径的前缀，因此在模块路径中添加主要版本后缀为每个不兼容的版本提供了独特的导入路径。\n主要版本v0或v1不允许使用主要版本后缀。无需在v0和v1之间更改模块路径，因为v0版本不稳定，并且没有兼容性保证。此外，对于大多数模块，v1与最后一个v0版本向后兼容；v1版本是对兼容性的承诺，而不是与v0相比不兼容的更改。\n","permalink":"https://guangchen811.github.io/golang/go_mod/","summary":"No.2","title":"Go Modules Reference中文翻译"},{"content":"Recently, I found a brilliant MLE interview guiding book written by Chip Huyen. In this book, Chip share her experience about types of Machine Learning Jobs, types of companies, Interview pipeline and some other things. Besides, what interests me most is that this book contains over 200 questions about ML. In this blog, I hope to organize the results of these questions as much as possible.\n5 Math 5.1 Algebra and (little) calculus 5.1.1 Vectors 1. Dot product   Q: [E]what\u0026rsquo;s the geometric interpretation of the dot product of two vectors?\nA: In Euclidean geometry, A vector can be pictured as an arrow. The dot product of two Euclidean vectors $\\vec{a}$ and $\\vec{b}$ is defined by $$ \\vec{a}\\cdot\\vec{b} = ||\\vec{a}||\\ ||\\vec{b}||\\cos{\\theta} $$ where $\\theta$ is the angle between $\\vec{a}$ and $\\vec{b}$.\n  Q: [E] Given a vector $\\vec{u}$, find vector $\\vec{v}$ of unit length such that the dot product of $\\vec{u}$ and $\\vec{v}$ is maximum.\nA: $$\\vec{v} = \\frac{\\vec{u}}{||\\vec{u}||}$$\n  2. outer product   Q: [E] Given two vectors $\\vec{a}=[3,2,1]$ and $\\vec{b}=[-1,0,1]$. Calculate the outer product $\\vec{a}^{T}\\vec{b}$? A: $$\\vec{a}^T\\vec{b}= \\begin{bmatrix} a_1b_1 \u0026amp; a_1b_2 \u0026amp; a_1b_3 \\\\ a_2b_1 \u0026amp; a_2b_2 \u0026amp; a_2b_3 \\\\ a_3b_1 \u0026amp; a_3b_2 \u0026amp; a_3b_3 \\end{bmatrix}= \\begin{bmatrix} -3 \u0026amp; 0 \u0026amp; 3 \\\\ -2 \u0026amp; 0 \u0026amp; 2 \\\\ -1 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$\n  Q: [M] Give an example of how the outer product can be useful in ML.\nA:\n  ","permalink":"https://guangchen811.github.io/mle/answerhuyenquestions/","summary":"Answers of questionis in Machine Learning Interviews Book written by Chip Huyen","title":"AnswerHuyenQuestions"},{"content":"Description You are given an array trees where trees [i] = [xi, yi] represents the location of a tree in the garden.\nYou are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter.\nFor example: Input: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[3,3],[2,4],[4,2]] Intuition This problem is a typical Convex Hull Algorithm. There are many common Algorithm to solve this kind of problem. Let\u0026rsquo;s describe Jarvis Algorithm, Graham Algorithm, Andrew Algorithm at here.\nAlgorithm Jarvis Algorithm The idea of Jarvis Algorithm is simple. We begin as the node which must on the contex hull, for example, the leftmost point $A_1$. Then we choose $A_2$ to ensure all nodes are on the left(right) side of the link $\\vec{AB}$. Repat the process to find $A_3, A_4, A_5,\\cdots$.\nCode class Solution { public: int cross(vector\u0026lt;int\u0026gt; \u0026amp; p, vector\u0026lt;int\u0026gt; \u0026amp; q, vector\u0026lt;int\u0026gt; \u0026amp; r) { return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; outerTrees(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; trees) { int n = trees.size(); if (n \u0026lt; 4) { return trees; } int leftMost = 0; for (int i = 0; i \u0026lt; n; i++) { if (trees[i][0] \u0026lt; trees[leftMost][0]) { leftMost = i; } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;bool\u0026gt; visit(n, false); int p = leftMost; do { int q = (p + 1) % n; for (int r = 0; r \u0026lt; n; r++) { /* If r is on the right of pq，q = r */ if (cross(trees[p], trees[q], trees[r]) \u0026lt; 0) { q = r; } } /* Is there a node i, to make p 、q 、i on a line. */ for (int i = 0; i \u0026lt; n; i++) { if (visit[i] || i == p || i == q) { continue; } if (cross(trees[p], trees[q], trees[i]) == 0) { res.emplace_back(trees[i]); visit[i] = true; } } if (!visit[q]) { res.emplace_back(trees[q]); visit[q] = true; } p = q; } while (p != leftMost); return res; } }; Complexity Analysis  Time Complexity: $O(n^2)$ Space Complexity: $O(n)$  ","permalink":"https://guangchen811.github.io/leetcode/erect-the-fence/","summary":"No.587","title":"Erect the Fence"},{"content":"Description Given an array of positive integers nums and a positive integer target return the minimal legth of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nIntuition We could keep 2 pointer, one for the start and the other for the end of current subarray, and make optimal moves so as to keep the sum greater than s as well as maintain the lowest size possible.\nAlgorithm Code class Solution { public: int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int ans = INT_MAX; int left = 0; int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; while (sum \u0026gt;= target) { ans = min(ans, i + 1 -left); sum -= nums[left++]; } } return (ans != INT_MAX) ? ans : 0; } }; Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/minimum-size-subarray-sum/","summary":"No.209","title":"Minimum Size Subarray Sum"},{"content":"Description Given the root of a binary search tree, rearrange the tree in in-order so that the left most node in the tree is now the root of the tree, and every node has no left child and only one right child.\nIntuition If root.left is not None, make root.left as root and root.left.right as root.left recursively.\nAlgorithm Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def increasingBST(self, root: TreeNode) -\u0026gt; TreeNode: if root == None: return None if root.left == None: root.right = self.increasingBST(root.right) return root node = root.left root.left = node.right node.right = root return self.increasingBST(node) Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/increasing-order-search-tree/","summary":"No.897","title":"Increasing Order Search Tree"},{"content":"Description Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nIntuition Visit nodes according to the value from largest to smallest. Maintain a global variable SUM.\nAlgorithm Pseudocode  Initial a global variable SUM.\nVisit root node using the follow function:\n  If root is Null, return.\nvisit root.right.\nSUM += root.val.\nroot.val = SUM.\nvisit root.left.\n Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: self.SUM = 0 self.visit(root) return root def visit(self, root): if root == None: return self.visit(root.right) self.SUM += root.val root.val = self.SUM self.visit(root.left) Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/convert-bst-to-greater-tree/","summary":"No.538","title":"Convert BST to Greater Tree"},{"content":"Description Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\nIntuition We can replace odds with 1 and evens with o, and then generate a list cur_odd. cur_odd[i] is equal to the number of odds until i. Now, we just need to count the number of pairs in cur_odd which difference is equal to k.\nAlgorithm In fact, it\u0026rsquo;s not necessary to build cur_odd explicitly. A hash map can make things easier.\nPseudocode  Initial a map as {0:1}.\nInitial current odd numbers as 0.\nInitial answer as 0.\nFor each number in numbers.\n If the number is a odd\n Let cur_odd add one.\n Else, if current odd numbers - k in the map.\n Let the answer add map[current odd numbers - k] Else, if current odd numbers not in the map.\n  Set map[current odd numbers] as 0.\n Let map[current odd numbers] add one.\n return the answer.\n Code class Solution: def numberOfSubarrays(self, nums: List[int], k: int) -\u0026gt; int: mp = {0:1} cur_odd = 0 ans = 0 for num in nums: if num % 2 == 1: cur_odd += 1 if cur_odd-k in mp: ans += mp[cur_odd-k] if not cur_odd in mp: mp[cur_odd] = 0 mp[cur_odd] += 1 return ans Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(n)$  ","permalink":"https://guangchen811.github.io/leetcode/count-number-of-nice-subarrays/","summary":"No.1248","title":"Count Number of Nice Subarrays"},{"content":"Description You are given two strings s1 and s2 of equal length consisting of letters \u0026quot;x\u0026quot; and \u0026quot;y\u0026quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].\nReturn the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.\nIntuition Given a index i, there are totally 4 possiblilities of s1[i] and s2[i]: x-x,y-y,x-yandy-x. x-x and y-y have been matched, we just need to process two other situations.\nAlgorithm Assum there are a pairs of x-y and b pairs of y-x. For 2 pairs of x-y or y-x, we can swap 1 steps to make them matching: \u0026quot;xx\u0026quot;|\u0026quot;yy\u0026quot;$\\rightarrow$\u0026quot;xy\u0026quot;|\u0026quot;xy\u0026quot;. For one x-y and one y-x, we need 2 steps: \u0026quot;xy\u0026quot;|\u0026quot;yx\u0026quot;$\\rightarrow$\u0026quot;xx\u0026quot;|\u0026quot;yy\u0026quot;$\\rightarrow$\u0026quot;xy\u0026quot;|\u0026quot;xy\u0026quot;.\nSo, if a and b are both even. We just need $\\frac{a+b}{2}$ steps without other process.\nIf one of a and b is even and the other is odd, we can\u0026rsquo;t make it match any way.\nIf their are both odd, we need $\\frac{a+b-2}{2}+2=\\frac{a+b}{2}+1$ steps.\nPseudocode  Read s1 and s2 to get a and b.\nIf only one of a and b is even, return -1.\nElse if both a and b are even, return $\\frac{a+b}{2}$.\nElse return $\\frac{a+b}{2}+1$\n Code class Solution: def minimumSwap(self, s1: str, s2: str) -\u0026gt; int: a = 0 b = 0 for i in range(len(s1)): if s1[i] == \u0026#39;x\u0026#39; and s2[i] == \u0026#39;y\u0026#39;: a += 1 elif s1[i] == \u0026#39;y\u0026#39; and s2[i] == \u0026#39;x\u0026#39;: b += 1 if a%2==0 and b%2==0: return int((a+b)/2) elif a%2==1 and b%2==1: return int((a+b)/2+1) else: return -1 Complexity Analysis  Time Complexity: $O(n)$. Space Complexity: $O(1)$.  ","permalink":"https://guangchen811.github.io/leetcode/minimum-swaps-to-make-strings-equal/","summary":"No.1247","title":"Minimum Swaps to Make Strings Equal"},{"content":"Description You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node\u0026rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nIntuition There are only two possibilities when we searching a node:\n node is equal to the value node is not equal to the value  Algorithm When the node is equal to the value, we just need to return it. Otherwise, we just need to visit its left or right child recursively.\nPseudocode  visit root node.\n If root is null or root\u0026rsquo;s value is equal to target value, return the root.\nOtherwises, if root\u0026rsquo;s value is bigger than target value.\n visit root\u0026rsquo;s left child.\n Otherwises\n visit root\u0026rsquo;s right child.\n   Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def searchBST(self, root: Optional[TreeNode], val: int) -\u0026gt; Optional[TreeNode]: if (root == None or root.val == val): return root elif root.val \u0026lt; val: return self.searchBST(root.right, val) else: return self.searchBST(root.left, val) Complexity Analysis  Time Complexity: $O(\\log{n})$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/searchinabinarysearchtree/","summary":"No.700","title":"Search in a Binary Seaerch Tree"},{"content":"Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nIntuition Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\nAlgorithm Just like how we would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of $l1$ and $l2$. Since each digit is in the range of 0\u0026hellip;9, summing two digits may \u0026ldquo;overflow\u0026rdquo;. For example $5+7=12$. In this case, we set the current digit to 2 and bring over the $carry=1$ to the next iteration. $carry$ must be either $0$ or $1$ because the largest possible sum of two digits (including the carry) is $9+9+1=19$.\nPseudocode  Initialize current node to dummy head of the returning list.\nInitialize $carry$ to 0.\nInitialize $p$ and $q$ to head of $l1$ and $l2$ respectively. Loop through lists $l1$ and $l2$ until you reach both ends.\n Set $x$ to node $p$\u0026rsquo;s value. If $p$ has reached the end of $l1$, set to 0.\nSet $y$ to node $q$\u0026rsquo;s value. If $q$ has reached the end of $l2$, set to 0.\nSet $sum=x+y+carry$.\nUpdate $carry = sum/10$\nCreate a new node with teh digit value of ($sum\\mod{10}$) and set it to current node\u0026rsquo;s next, then advance current node to next.\nAdvance both $p$ and $q$.\n Check if $carry=1$, if so append a new node with digit 1 to the returning list.\nReturn dummy head\u0026rsquo;s next node.\n Code # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummyHead = ListNode(val=0) p = l1 q = l2 curr = dummyHead carry = 0 while(p != None or q != None): if p != None: x = p.val else: x = 0 if q != None: y = q.val else: y = 0 sum = carry + x + y carry = sum // 10 curr.next = ListNode(val=sum % 10) curr = curr.next if(p != None): p = p.next if(q != None): q = q.next if (carry \u0026gt; 0): curr.next = ListNode(carry) return dummyHead.next Complexity Analysis   Time Complexity: $O(\\max{(m,n)})$. Assume that $m$ and $n$ represents the length of $l1$ and $l2$ respectively, the algorithm above iterates at most $\\max{(m,n)}$ times.\n  Space Complexity: $O(\\max{(m,n)})$. The length of the new list is at most $\\max{(m,n)}+1$.\n  ","permalink":"https://guangchen811.github.io/leetcode/add-two-numbers/","summary":"No.2","title":"Add Two Numbers"}]