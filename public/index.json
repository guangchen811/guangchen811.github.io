[{"content":"DGL offical document about customizing GNN layers is here\nDGL provides many message passingfunctions for uses to customize their own GNN layers.\n","permalink":"https://guangchen811.github.io/posts/my-own-gnn-layer/","summary":"DGL offical document about customizing GNN layers is here\nDGL provides many message passingfunctions for uses to customize their own GNN layers.","title":"My Own GNN Layer"},{"content":"This is python offical document that explain the difference between Scope and Namespace.\nMy summary after reading the document is as follows.\nWhat is namespace and scope？ A namespace is a mapping from names to objects. Examples of namespaces are: the set of built-in names(containing functions usch as abs(), and built-in exception names); the global names in a module; and the localnames in a function invocation. In a sense the set of attributes of an object aloso form a namespace.\nThe important thhing to know about namespaces is that there is absolutely norelation between names in dfferent namespaces; for instance, two different modules may both define a function maximize without confusion - users of the modules must prefix it with the module name.\nNamespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits.\nA scope is a textual region of a Python program where a namespace is directly accessible. \u0026ldquo;Directly accessible\u0026rdquo; here means that an unqualified reference to a name attempts to find the name in the namespace.\nAlthough scopes are determined statically, they are used dynamically. At any time during eecution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n the innermost scope, which is searched first, contains the local names the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also non-global names the next-to-last scope contains the current module\u0026rsquo;s global names the outermost scope (searched last) is the namespace containing built-in names  This blog is great: Mastering python namespaces and scopes\n","permalink":"https://guangchen811.github.io/python/namespace/","summary":"This is python offical document that explain the difference between Scope and Namespace.\nMy summary after reading the document is as follows.\nWhat is namespace and scope？ A namespace is a mapping from names to objects. Examples of namespaces are: the set of built-in names(containing functions usch as abs(), and built-in exception names); the global names in a module; and the localnames in a function invocation. In a sense the set of attributes of an object aloso form a namespace.","title":"Namespace and scope"},{"content":"source\n介绍 模块是Go语言管理依赖的方式.\n这篇文档详细地说明了Go语言的模块系统. 关于如何创建Go项目，可以参看如何写Go语言程序. 关于使用模块、将项目迁移到模块，和其他相关的话题，请参看从使用Go模块开始的系列博客.\n模块、包和版本 模块是统一发布、版本控制和分发的包的集合. 我们可以直接从版本控制仓库中下载模块，也可以从一些模块代理服务器下载.\n一个模块可以由go.mod文件中标明的模块路径来识别. 除模块路径外，go.mod 文件中还包含了模块间依赖的信息.模块的根目录为包含go.mod文件的路径. 主模块是指包含go命令被调用的目录的模块.\n模块中的每一个包是指在相同路径下、一同被编译的源文件的集合. 一个包路径是由模块路径和包含包的子目录(指从模块根目录出发的相对路径)拼接而成的. 例如，模块\u0026quot;golang.org/x/net\u0026quot;的\u0026quot;html\u0026quot;路径中包含的包的路径为\u0026quot;golang.org/x/net/html\u0026quot;.\n模块路径 模块路径是指一个模块的标准名称，他会在go.mod文件中使用mod指令声明. 如上文所述，模块路径是模块内包路径的前缀.\n一个模块路径既要指明模块的功能，也要指明我们可以在哪里找到它。一般来说，模块路径会包含仓库根路径、仓库中文件夹的路径(一般为空，这是仓库的根目录就是模块的根路径)，以及一个主版本号后缀(只针对主版本号大于等于2时)。\n 仓库根路径是模块路径中对应版本控制仓库根路径的部分. 大多数模块都定义在其仓库的根路径上。例如仓库根路径golang.org/x/net就是与其同名的模块的根路径。关于go命令如何使用HTTP协议从模块中定位一个仓库请参阅从模块路径中找到仓库. 如果模块没有被定义在仓库的根目录，模块子目录就是模块名称中指明模块在仓库中地址的部分。模块子目录也可以作为前缀指明版本，如模块golang.org/x/tools/gopls就是根路径为golang.org/x/tools/gopls的仓库中的gopls子目录。参看，将版本映射为提交和仓库中的模块路径. 在发布主版本号大于等于2的模块时，模块路径必须以主版本后缀，如/v2结尾。他也可以作为子目录的一部分。例如，路径为golang.org/x/repo/sub/v2的模块可能在仓库golang.org/x/repo的/sub路径中，也可能在/sub/v2路径中.  如果一个模块可能被其他模块依赖，我们只有在遵守上述规则的情况下，go命令才能正确的找到并下载该模块。此外，模块路径中的字符还有一些词法限制。\n版本(version) 版本号表明了模块的一个不可变快照，它可以是发布版或预发布版。每个版本都以字母 v开头，随后是可读的版本信息。有关如何格式化、解释和比较版本的详细信息，请参阅语义版本 2.0.0\n总的来说，一个语义版本包含三个由.分割的非负整数(从左到右分别标识主要版本号、次要版本号和布丁版本号). 补丁版本后面可以跟一个以连字符开头的可选预发布字符串。 预发布字符串或补丁版本后面可以跟以加号开头的构建元数据字符串。 例如，v0.0.0、v1.12.134、v8.0.5-pre 和 v2.0.9+meta 都是有效版本。\n版本的每个部分都表示版本是否稳定以及是否与以前的版本兼容。\n 当一个向后不兼容的改变发生时（如一个包被删除时），主要版本号必须加一，次要版本号和补丁版本号需要置为0. 当一个向后兼容的改变发生时（如增加了一个新的函数），次要版本号需要加一，补丁号需要置为0. 当发生了对模块的对外接口没有变化的改动时（如修复了一个bug或者进行了代码优化），补丁号需要加1. pre-release后缀用于标注预发行版. 预发行版通常先于发行版发布. 例如，v1.2.3-pre要早于v1.2.3. 为了进行版本比较，构建元数据（build metadata）后缀会被忽略. 标有构建元数据的版本会被版本控制仓库忽略，但是构建元数据会被保留在go.mod文件指定的版本中。后缀+incompatible表示发布在迁移到模块主版本号大于等于2的版本之前发行的版本.  如果一个版本的主版本为0或者带有pre后缀，那么该版本是不稳定的. 例如v0.2.0可能并不兼容v0.1.0, v1.5.0-beta可能不兼容v1.5.0.\nGo语言可以通过使用标签、分支和版本重命名来访问不符合上述命名规范的模块. 然而，在主模块中，go命令会自动把不符合标准的名字转换为标准版本号. go命令还会自动删掉构建元数据后缀（除+incompatible之外）。这会导致产生伪版本(pseudo-version)：指一个编码了版本标识或者时间戳的预发行版. 例如go get -d golang.org/x/net@daa7c041将会被转换为v0.0.0-20191109021931-daa7c04131f4. 标准版本被要求放在主模块外。此外，如果非标准的版本如master出现在go.mod文件中，go命令会报错.\n伪版本 一个伪版本特指用于在版本控制仓库中编码特别版本信息的预发行版本. 例如v0.0.0-20191109021931-daa7c04131f5就是一个伪版本.\n伪版本可能用于重命名没有语义版本标签的版本. 主要出现在创建版本标签前的测试提交，如在开发分支中的提交.\n每一个伪版本号由三部分组成：\n 一个基本版本前缀(vX.0.0或X.Y.Z-0)，可以来自于修订前的语义版本标签，如果没有的话就定为vX.0.0. 时间戳(yyyymmddhhmmss),指创建该版本时的世界标准时间(UTC). 在Git中表示提交时间而非创作时间. 一个修订标识符(abcdefabcdef)，为提交哈希的12位前缀. 如果是子版本，则为12个0.  由于基本版本号的不同，伪版本号可能为以下三种形式之一. 这确保了伪版本号一定高于基本版本号，但低于下一个有标签的版本号.\n-vX.0.0-yyyymmddhhmmss-abcdefabcdef被用于基本版本号未知的情况. 与所有版本一样，主版本号必须匹配模块的主版本后缀. -vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef被用于基本版本号为vX.Y.Z-pre的情形. -vX.Y.(Z+1).0.yyyymmddhhmmss-abcdefabcdef被用于主版本号为vX.Y.Z的情况. 例如，如果基本版本号为v1.2.3，伪版本号可能是v1.2.4-0.20191109021931-daa7c04131f5.\n通过使用不同的基本版本号，多个伪版本号可能指向同一次提交. 这种情况在一个低版本在伪版本产生后被打上新标签时会自然的发生。\n这种形式为伪版本提供了两个有用的特性：\n 具有已知基本版本号的伪版本排序高于基本版本但低于其他预发行版本. 基于相同版本的伪版本按时间排序.  go命令会执行以下操作来确保模块作者可以控制伪版本如何与其他版本比较，伪版本是指模块提交历史中的一部分的版本.\n 如果一个基本版本已被指明，那么必须存在一个对应的语义版本标签作为伪版本描述的版本的祖先. 这可以避免开发者绕开最小版本号选择原则，使用一个比所有版本都高的版本，如v1.999.999-99999999999999-daa7c04131f5. 时间戳必须匹配重命名版本的时间戳. 这是为了防止攻击者使用相很多相同版本号淹没模块代理. 同时也防止了模块使用者修改版本的相对顺序. 修订版必须是模块仓库中分支或标签之一的祖先. 这是为了防止攻击者引用未经允许的修改或拉取请求.  伪版本不需要手动输入. 许多命令都会接受提交哈希或者分支名称，并将其自动转化为伪版本号。例如:\ngo get -d example.com/mod@master go list -m -json example.com/mod@abcd1234 Major version suffixes 从主版本2开始，模块路径必须有一个主版本号前缀如/v2来匹配主版本号。例如，一个模块可以将v1.0.0存在example.com/mod路径下，那么它必须在example.com/mod/v2路径存储其v2.0.0版本.\n主版本号后缀需要实现导入兼容性原则：\n 如果一个旧的包和新的包有相同的引用路径，新的包必须向后兼容旧的包。  根据定义，模块新主要版本中的软件包与之前主要版本的相应软件包不向后兼容。因此，从v2开始，软件包需要新的导入路径。这是通过在模块路径中添加一个主要版本后缀来实现的。由于模块路径是模块中每个软件包导入路径的前缀，因此在模块路径中添加主要版本后缀为每个不兼容的版本提供了独特的导入路径。\n主要版本v0或v1不允许使用主要版本后缀。无需在v0和v1之间更改模块路径，因为v0版本不稳定，并且没有兼容性保证。此外，对于大多数模块，v1与最后一个v0版本向后兼容；v1版本是对兼容性的承诺，而不是与v0相比不兼容的更改。\n","permalink":"https://guangchen811.github.io/golang/go_mod/","summary":"No.2","title":"Go Modules Reference中文翻译"},{"content":"Recently, I found a brilliant MLE interview guiding book written by Chip Huyen. In this book, Chip share her experience about types of Machine Learning Jobs, types of companies, Interview pipeline and some other things. Besides, what interests me most is that this book contains over 200 questions about ML. In this blog, I hope to organize the results of these questions as much as possible.\n5 Math 5.1 Algebra and (little) calculus 5.1.1 Vectors 1. Dot product   Q: [E]what\u0026rsquo;s the geometric interpretation of the dot product of two vectors?\nA: In Euclidean geometry, A vector can be pictured as an arrow. The dot product of two Euclidean vectors $\\vec{a}$ and $\\vec{b}$ is defined by $$ \\vec{a}\\cdot\\vec{b} = ||\\vec{a}||\\ ||\\vec{b}||\\cos{\\theta} $$ where $\\theta$ is the angle between $\\vec{a}$ and $\\vec{b}$.\n  Q: [E] Given a vector $\\vec{u}$, find vector $\\vec{v}$ of unit length such that the dot product of $\\vec{u}$ and $\\vec{v}$ is maximum.\nA: $$\\vec{v} = \\frac{\\vec{u}}{||\\vec{u}||}$$\n  2. outer product   Q: [E] Given two vectors $\\vec{a}=[3,2,1]$ and $\\vec{b}=[-1,0,1]$. Calculate the outer product $\\vec{a}^{T}\\vec{b}$? A: $$\\vec{a}^T\\vec{b}= \\begin{bmatrix} a_1b_1 \u0026amp; a_1b_2 \u0026amp; a_1b_3 \\\\ a_2b_1 \u0026amp; a_2b_2 \u0026amp; a_2b_3 \\\\ a_3b_1 \u0026amp; a_3b_2 \u0026amp; a_3b_3 \\end{bmatrix}= \\begin{bmatrix} -3 \u0026amp; 0 \u0026amp; 3 \\\\ -2 \u0026amp; 0 \u0026amp; 2 \\\\ -1 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$\n  Q: [M] Give an example of how the outer product can be useful in ML.\nA:\n  ","permalink":"https://guangchen811.github.io/mle/answerhuyenquestions/","summary":"Answers of questionis in Machine Learning Interviews Book written by Chip Huyen","title":"AnswerHuyenQuestions"},{"content":"Description You are given an array trees where trees [i] = [xi, yi] represents the location of a tree in the garden.\nYou are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter.\nFor example: Input: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[3,3],[2,4],[4,2]] Intuition This problem is a typical Convex Hull Algorithm. There are many common Algorithm to solve this kind of problem. Let\u0026rsquo;s describe Jarvis Algorithm, Graham Algorithm, Andrew Algorithm at here.\nAlgorithm Jarvis Algorithm The idea of Jarvis Algorithm is simple. We begin as the node which must on the contex hull, for example, the leftmost point $A_1$. Then we choose $A_2$ to ensure all nodes are on the left(right) side of the link $\\vec{AB}$. Repat the process to find $A_3, A_4, A_5,\\cdots$.\nCode class Solution { public: int cross(vector\u0026lt;int\u0026gt; \u0026amp; p, vector\u0026lt;int\u0026gt; \u0026amp; q, vector\u0026lt;int\u0026gt; \u0026amp; r) { return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; outerTrees(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; trees) { int n = trees.size(); if (n \u0026lt; 4) { return trees; } int leftMost = 0; for (int i = 0; i \u0026lt; n; i++) { if (trees[i][0] \u0026lt; trees[leftMost][0]) { leftMost = i; } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;bool\u0026gt; visit(n, false); int p = leftMost; do { int q = (p + 1) % n; for (int r = 0; r \u0026lt; n; r++) { /* If r is on the right of pq，q = r */ if (cross(trees[p], trees[q], trees[r]) \u0026lt; 0) { q = r; } } /* Is there a node i, to make p 、q 、i on a line. */ for (int i = 0; i \u0026lt; n; i++) { if (visit[i] || i == p || i == q) { continue; } if (cross(trees[p], trees[q], trees[i]) == 0) { res.emplace_back(trees[i]); visit[i] = true; } } if (!visit[q]) { res.emplace_back(trees[q]); visit[q] = true; } p = q; } while (p != leftMost); return res; } }; Complexity Analysis  Time Complexity: $O(n^2)$ Space Complexity: $O(n)$  ","permalink":"https://guangchen811.github.io/leetcode/erect-the-fence/","summary":"No.587","title":"Erect the Fence"},{"content":"Source: tutorials point\nUseful Links: www.cplusplus.com\nC++ is a middle-level programming language developed by Bjarne Stroustrup starting in 1979 at Bell Labs. C++ runs on a variety of platforms, such as Windows, Mac OS, and the various versions of UNIX. This C++ tutorial adopts a simple and practical approach to describe the concepts of C++ for beginners to advanded software engineers.\nWhy to Learn C++ C++ is a MUST for students and working professionals to become a great Software Engineer. I will list down some of the key advantages of learning C++:\n C++ is very close to hardware, so you get a chance to work at a low level which gives you lot of control interms of memory management, better performance and finally a robust software development. C++ programming gives you a clear understanding about Object Oriented Programming. You will understand low level implementation of polymorphism when you will implement virtual tables and virtual table pointers, or dynamic type identification. C++ is one of the every green programming languages and loved by millions of software developers. If you are a great C++ programmer then you will never sit without work and more importantly you will get highly paid for your work. C++ is the most widely used programming languages in application and system programming. So you can choose your area of interest of software development. C++ really teaches you the difference between compiler, linker and loader, different data types, storage classes, variable types their scopes etc.  Hello world using C++ Just to give you a little excitement about C++ programming, I\u0026rsquo;m going to give you a small conventional C++ Hello World program.\nC++ is a super set of C programming with additional implementation of object-oriented concepts.\n#include \u0026lt;iostream\u0026gt;using namespace std; // main() is where program execution begis. int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; // prints Hello World  return 0; } Overview C++ is a statically typed, compiled, general-purpose, case-sensitive, free-form programming language that supports procedural, object-oriented, and generic programming.\nC++ is regraded as a middle-level language, as it comprises a combination of both high-level and low-level language features.\nC++ was developed by Bjarne Stroustrup starting in 1979 at Bell Labs in Murray Hill, New Jersey, as an enhancement to the C language and originally named C with Classes but later it was renamed C++ in 1983.\nC++ is a superset of C, and that virtually any legal C program is a legal C++ program.\nNote: A programming language is said to use static typing when type checking is performed during compile-time as opposed to run-time.\nObject-Oriented Programming C++ fully supports object-oriented programming, including the four pillars of object-oriented development:\n Encapsulation Data hiding Inheritance Polymorphism  standard Libraries standard C++ consists of three important parts:\n The core language giving all the building blocks including variables, data types and literals, etc. The C++ Standard Library giving a rich set of functions manipulating files, stings, etc. The Standard Template Library (STL) giving a rich set of methods manipulating data structures, etc.  The ANSI Standard The ANSI standard is an attempt to ensure that C++ is portable; that code you write for Microsoft\u0026rsquo;s compiler will compile without errors, using a compiler on a Mac, UNIX, a Windows box, or an Alpha.\nThe ANSI standard has been stable for a while, and all the major C++ compiler manufacturers support the ANSI standard.\nLearning C++ The most important thing while learning C++ is to focus on concepts.\nThe purpose of learning a programming language is to become a better programmer; that is, to become more effective at designing and implementing new systems and at maintaining old ones.\nC++ supports a variety of programming styles. You can write in the style of Fortran, C, Smalltalk, etc., in any language. Each style can achieve its aims effectively while maintaining runtime and space efficiency.\nEnvironment Setup Installing GNU C/C++ Compiler UNIX/Linux Installation If you are using Linux or UNIX then check whether GCC is installed on your system by entering the following command from the command line\n$ g++ -v If you have installed GCC, then it should print a message such as the following\nApple clang version 13.1.6 (clang-1316.0.21.2) Target: arm64-apple-darwin21.4.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin if GCC is not installed, then you will have to install it yourself using the detailed instructions available at https://gcc.gnu.org/install/.\nWindows Installation To install GCC at Windows you need to install MinGW. To install MinGW, goto the MinGW homepage, http://www.mingw.org/, and follow the link to the MinGW download page. Download the latest version of the MinGW installation program which should be named MinGW-\u0026lt;version\u0026gt;.exe.\nWhile installing MinGW, at a minimum, you must install gcc-core, gcc-g++, binutils, and the MinGW runtime, but you may wish to install more.\nAdd the bin subdirectory of your MinGW installation to your PATH environment variable so that you can specify these tools on the command line by their simple names.\nWhen the installation is complete, you will be able to run gcc, g++, ar, ranlib, dlltool, and several other GNU tools from the Windows command line.\nBasic Syntax When we consider a C++ program, it can be defined as a collection of object that communicate via invoking each other\u0026rsquo;s methods. Let us now briefly look into what a class, object, methods, and instant variables mean.\n  Class: A class can be defined as a template/blueprint that describes the behaviors/states that object of its type support.\n  Object: Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors - wagging, barking, eating. An object is an instance of a class.\n  Methods - A method is basically a behavior. A calss can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.\n  Instance Variables: Each object has its unique set of instance variables. An object\u0026rsquo;s state is created by the values assigned to these instance variable.\n  C++ Program Structure Let us look at a simple code that would print the words Hello World.\n#include \u0026lt;iostream\u0026gt;using namespace std; // main() is where program execution begins. int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; // prints Hello World  return 0; } Let us look at the various parts of the above program\n  The C++ language defines several headers, which contain information that is either necessary or useful to your program. For this program, the header  is needed.\n  The line using namespace std; tells the compiler to use the std namespace. Namespaces are a relatively recent addition to C++.\n  The next line '// main() is where program execution begins. is a single-line comment available in C++. Single-line comments begin with // and stop at the end of the line.\n  The line int main() is the main function where program execution begins.\n  The next line cout \u0026laquo; \u0026ldquo;Hello World\u0026rdquo;; causes the message \u0026ldquo;Hello World\u0026rdquo; to be displayed on the screen.\n  The next line return 0; terminates main() function and causes it to return the value 0 to the calling process.\n  Compile and Execute C++ Program We can save, compile and run the program by the steps given below.\n  Open a text editor and add the code as above.\n  Save the file as: hello.cpp\n  Open a command prompt and got o the directory where you saved the file.\n  Type \u0026lsquo;g++ hello.cpp\u0026rsquo; and press enter to compile your code. If there are no errors in your code, the command prompt will take you to the next line and would generate a.out executable file.\n  Now, type \u0026lsquo;./a.out\u0026rsquo; to run your program.\n  You will be able to see \u0026lsquo;Hello World\u0026rsquo; printed on the window.\n  $ g++ hello.cpp $ ./a.out Hello World Semicolons and Blocks in C++ In C++, the semicolon is a statement terminator. That is, each individual statement must be ended with a semicolon. It indicates the end of one logical entity.\nFor example, following are three different staements\nx = y; y = y + 1; add(x, y); A block is a set of logically connected statements that are surrounded by opening and closing braces. For example\n{ cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; // prints Hello World  return 0; } C++ does not recognize the end of the lines as a terminator. For this reason, it does not matter where you put a statement in a line. For example\nx = y; y = y + 1; add(x, y); is the same as\nx = y; y = y + 1; add(x, y); C++ Identifiers A C++ identifier is a name used to identify a variable, function, class, module, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an undersocre (_) followed by zero or more letters, underscores, and digits(0 to 9).\nC++ does not allow punctuation characters such as @, $, and % within identifiers. C++ is a case-sensitive programming language. Thus, Manpower and manpower are two different Identifiers in C++.\nHere are some examples of acceptable identifiers\nmohd zara abc move_name a_123 myname50 _temp j a23b9 retVal C++ Keywords The following list shows the reserved words in C++. THese reserved words may not be used as constant or variable or any other identifier names.\n           asm eles new this   auto enum operator throw   bool explicit private true   break export protected try   case extern public typedef   catch false register typeid   char float reinterpret_cast typename   class for return union   const friend short unsigned   const_cast goto signed using   continue if sizeof virtual   default inlline static void   delete int static_cast volatile   do long struct wchar_t   double mutable switch while   dynamic_cast namespace template     C++ Data Types While writing program in any language, you need to use various variables to store various information. Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserver some space in memory.\nYou may like to store information of various data types like character, wide character, ineger, floating point, double floating point, boolean etc. Based on the data type of a variable, the operating system allocates memory and decides what can be stored in the reserved memory.\nPrimitive Built-in Types C++ offers the programmer a rich assortment of built-in as well as user defined data types. Following table lists down seven basic C++ data types\n   Type Keyword     Boolean bool   Character char   Integer int   Floating point float   Double floating point double   Valueless void   Wide character wchar_t    Serveral of the basic types can be modified using one of more of these type modifiers\n signed unsigned short long  The following table shows the variable type, how much memory it takes to store the value in memory, and what is maximum and minimum value which can be stored in such type of variables.\n   Type Typical Bit Width Typical Range     char 1 byte -127 to 127 or 0 to 255   unsigned char 1 byte 0 to 255   signed char 1 byte -127 to 127   int 4 bytes -2147483648 to 2147483647   unsigned int 4 bytes 0 to 4294967295   signed int 4 bytes -2147483648 to 2147483647   short int 2 bytes -32768 to 32767    ","permalink":"https://guangchen811.github.io/languagetutorial/cpp/","summary":"Source: tutorials point\nUseful Links: www.cplusplus.com\nC++ is a middle-level programming language developed by Bjarne Stroustrup starting in 1979 at Bell Labs. C++ runs on a variety of platforms, such as Windows, Mac OS, and the various versions of UNIX. This C++ tutorial adopts a simple and practical approach to describe the concepts of C++ for beginners to advanded software engineers.\nWhy to Learn C++ C++ is a MUST for students and working professionals to become a great Software Engineer.","title":"C++ Tutorial"},{"content":"Description Given an array of positive integers nums and a positive integer target return the minimal legth of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nIntuition We could keep 2 pointer, one for the start and the other for the end of current subarray, and make optimal moves so as to keep the sum greater than s as well as maintain the lowest size possible.\nAlgorithm Code class Solution { public: int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int ans = INT_MAX; int left = 0; int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; while (sum \u0026gt;= target) { ans = min(ans, i + 1 -left); sum -= nums[left++]; } } return (ans != INT_MAX) ? ans : 0; } }; Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/minimum-size-subarray-sum/","summary":"No.209","title":"Minimum Size Subarray Sum"},{"content":"Description Given the root of a binary search tree, rearrange the tree in in-order so that the left most node in the tree is now the root of the tree, and every node has no left child and only one right child.\nIntuition If root.left is not None, make root.left as root and root.left.right as root.left recursively.\nAlgorithm Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def increasingBST(self, root: TreeNode) -\u0026gt; TreeNode: if root == None: return None if root.left == None: root.right = self.increasingBST(root.right) return root node = root.left root.left = node.right node.right = root return self.increasingBST(node) Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/increasing-order-search-tree/","summary":"No.897","title":"Increasing Order Search Tree"},{"content":"Description Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nIntuition Visit nodes according to the value from largest to smallest. Maintain a global variable SUM.\nAlgorithm Pseudocode  Initial a global variable SUM.\nVisit root node using the follow function:\n  If root is Null, return.\nvisit root.right.\nSUM += root.val.\nroot.val = SUM.\nvisit root.left.\n Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: self.SUM = 0 self.visit(root) return root def visit(self, root): if root == None: return self.visit(root.right) self.SUM += root.val root.val = self.SUM self.visit(root.left) Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/convert-bst-to-greater-tree/","summary":"No.538","title":"Convert BST to Greater Tree"},{"content":"Description Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\nIntuition We can replace odds with 1 and evens with o, and then generate a list cur_odd. cur_odd[i] is equal to the number of odds until i. Now, we just need to count the number of pairs in cur_odd which difference is equal to k.\nAlgorithm In fact, it\u0026rsquo;s not necessary to build cur_odd explicitly. A hash map can make things easier.\nPseudocode  Initial a map as {0:1}.\nInitial current odd numbers as 0.\nInitial answer as 0.\nFor each number in numbers.\n If the number is a odd\n Let cur_odd add one.\n Else, if current odd numbers - k in the map.\n Let the answer add map[current odd numbers - k] Else, if current odd numbers not in the map.\n  Set map[current odd numbers] as 0.\n Let map[current odd numbers] add one.\n return the answer.\n Code class Solution: def numberOfSubarrays(self, nums: List[int], k: int) -\u0026gt; int: mp = {0:1} cur_odd = 0 ans = 0 for num in nums: if num % 2 == 1: cur_odd += 1 if cur_odd-k in mp: ans += mp[cur_odd-k] if not cur_odd in mp: mp[cur_odd] = 0 mp[cur_odd] += 1 return ans Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(n)$  ","permalink":"https://guangchen811.github.io/leetcode/count-number-of-nice-subarrays/","summary":"No.1248","title":"Count Number of Nice Subarrays"},{"content":"Description You are given two strings s1 and s2 of equal length consisting of letters \u0026quot;x\u0026quot; and \u0026quot;y\u0026quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].\nReturn the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.\nIntuition Given a index i, there are totally 4 possiblilities of s1[i] and s2[i]: x-x,y-y,x-yandy-x. x-x and y-y have been matched, we just need to process two other situations.\nAlgorithm Assum there are a pairs of x-y and b pairs of y-x. For 2 pairs of x-y or y-x, we can swap 1 steps to make them matching: \u0026quot;xx\u0026quot;|\u0026quot;yy\u0026quot;$\\rightarrow$\u0026quot;xy\u0026quot;|\u0026quot;xy\u0026quot;. For one x-y and one y-x, we need 2 steps: \u0026quot;xy\u0026quot;|\u0026quot;yx\u0026quot;$\\rightarrow$\u0026quot;xx\u0026quot;|\u0026quot;yy\u0026quot;$\\rightarrow$\u0026quot;xy\u0026quot;|\u0026quot;xy\u0026quot;.\nSo, if a and b are both even. We just need $\\frac{a+b}{2}$ steps without other process.\nIf one of a and b is even and the other is odd, we can\u0026rsquo;t make it match any way.\nIf their are both odd, we need $\\frac{a+b-2}{2}+2=\\frac{a+b}{2}+1$ steps.\nPseudocode  Read s1 and s2 to get a and b.\nIf only one of a and b is even, return -1.\nElse if both a and b are even, return $\\frac{a+b}{2}$.\nElse return $\\frac{a+b}{2}+1$\n Code class Solution: def minimumSwap(self, s1: str, s2: str) -\u0026gt; int: a = 0 b = 0 for i in range(len(s1)): if s1[i] == \u0026#39;x\u0026#39; and s2[i] == \u0026#39;y\u0026#39;: a += 1 elif s1[i] == \u0026#39;y\u0026#39; and s2[i] == \u0026#39;x\u0026#39;: b += 1 if a%2==0 and b%2==0: return int((a+b)/2) elif a%2==1 and b%2==1: return int((a+b)/2+1) else: return -1 Complexity Analysis  Time Complexity: $O(n)$. Space Complexity: $O(1)$.  ","permalink":"https://guangchen811.github.io/leetcode/minimum-swaps-to-make-strings-equal/","summary":"No.1247","title":"Minimum Swaps to Make Strings Equal"},{"content":"Description You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node\u0026rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nIntuition There are only two possibilities when we searching a node:\n node is equal to the value node is not equal to the value  Algorithm When the node is equal to the value, we just need to return it. Otherwise, we just need to visit its left or right child recursively.\nPseudocode  visit root node.\n If root is null or root\u0026rsquo;s value is equal to target value, return the root.\nOtherwises, if root\u0026rsquo;s value is bigger than target value.\n visit root\u0026rsquo;s left child.\n Otherwises\n visit root\u0026rsquo;s right child.\n   Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def searchBST(self, root: Optional[TreeNode], val: int) -\u0026gt; Optional[TreeNode]: if (root == None or root.val == val): return root elif root.val \u0026lt; val: return self.searchBST(root.right, val) else: return self.searchBST(root.left, val) Complexity Analysis  Time Complexity: $O(\\log{n})$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/searchinabinarysearchtree/","summary":"No.700","title":"Search in a Binary Seaerch Tree"},{"content":"Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nIntuition Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\nAlgorithm Just like how we would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of $l1$ and $l2$. Since each digit is in the range of 0\u0026hellip;9, summing two digits may \u0026ldquo;overflow\u0026rdquo;. For example $5+7=12$. In this case, we set the current digit to 2 and bring over the $carry=1$ to the next iteration. $carry$ must be either $0$ or $1$ because the largest possible sum of two digits (including the carry) is $9+9+1=19$.\nPseudocode  Initialize current node to dummy head of the returning list.\nInitialize $carry$ to 0.\nInitialize $p$ and $q$ to head of $l1$ and $l2$ respectively. Loop through lists $l1$ and $l2$ until you reach both ends.\n Set $x$ to node $p$\u0026rsquo;s value. If $p$ has reached the end of $l1$, set to 0.\nSet $y$ to node $q$\u0026rsquo;s value. If $q$ has reached the end of $l2$, set to 0.\nSet $sum=x+y+carry$.\nUpdate $carry = sum/10$\nCreate a new node with teh digit value of ($sum\\mod{10}$) and set it to current node\u0026rsquo;s next, then advance current node to next.\nAdvance both $p$ and $q$.\n Check if $carry=1$, if so append a new node with digit 1 to the returning list.\nReturn dummy head\u0026rsquo;s next node.\n Code # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummyHead = ListNode(val=0) p = l1 q = l2 curr = dummyHead carry = 0 while(p != None or q != None): if p != None: x = p.val else: x = 0 if q != None: y = q.val else: y = 0 sum = carry + x + y carry = sum // 10 curr.next = ListNode(val=sum % 10) curr = curr.next if(p != None): p = p.next if(q != None): q = q.next if (carry \u0026gt; 0): curr.next = ListNode(carry) return dummyHead.next Complexity Analysis   Time Complexity: $O(\\max{(m,n)})$. Assume that $m$ and $n$ represents the length of $l1$ and $l2$ respectively, the algorithm above iterates at most $\\max{(m,n)}$ times.\n  Space Complexity: $O(\\max{(m,n)})$. The length of the new list is at most $\\max{(m,n)}+1$.\n  ","permalink":"https://guangchen811.github.io/leetcode/add-two-numbers/","summary":"No.2","title":"Add Two Numbers"}]