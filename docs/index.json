[{"content":"Source: tutorials point\nUseful Links: www.cplusplus.com\nC++ is a middle-level programming language developed by Bjarne Stroustrup starting in 1979 at Bell Labs. C++ runs on a variety of platforms, such as Windows, Mac OS, and the various versions of UNIX. This C++ tutorial adopts a simple and practical approach to describe the concepts of C++ for beginners to advanded software engineers.\nWhy to Learn C++ C++ is a MUST for students and working professionals to become a great Software Engineer. I will list down some of the key advantages of learning C++:\n C++ is very close to hardware, so you get a chance to work at a low level which gives you lot of control interms of memory management, better performance and finally a robust software development. C++ programming gives you a clear understanding about Object Oriented Programming. You will understand low level implementation of polymorphism when you will implement virtual tables and virtual table pointers, or dynamic type identification. C++ is one of the every green programming languages and loved by millions of software developers. If you are a great C++ programmer then you will never sit without work and more importantly you will get highly paid for your work. C++ is the most widely used programming languages in application and system programming. So you can choose your area of interest of software development. C++ really teaches you the difference between compiler, linker and loader, different data types, storage classes, variable types their scopes etc.  Hello world using C++ Just to give you a little excitement about C++ programming, I\u0026rsquo;m going to give you a small conventional C++ Hello World program.\nC++ is a super set of C programming with additional implementation of object-oriented concepts.\n#include \u0026lt;iostream\u0026gt;using namespace std; // main() is where program execution begis. int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; // prints Hello World  return 0; } Overview C++ is a statically typed, compiled, general-purpose, case-sensitive, free-form programming language that supports procedural, object-oriented, and generic programming.\nC++ is regraded as a middle-level language, as it comprises a combination of both high-level and low-level language features.\nC++ was developed by Bjarne Stroustrup starting in 1979 at Bell Labs in Murray Hill, New Jersey, as an enhancement to the C language and originally named C with Classes but later it was renamed C++ in 1983.\nC++ is a superset of C, and that virtually any legal C program is a legal C++ program.\nNote: A programming language is said to use static typing when type checking is performed during compile-time as opposed to run-time.\nObject-Oriented Programming C++ fully supports object-oriented programming, including the four pillars of object-oriented development:\n Encapsulation Data hiding Inheritance Polymorphism  standard Libraries standard C++ consists of three important parts:\n The core language giving all the building blocks including variables, data types and literals, etc. The C++ Standard Library giving a rich set of functions manipulating files, stings, etc. The Standard Template Library (STL) giving a rich set of methods manipulating data structures, etc.  The ANSI Standard The ANSI standard is an attempt to ensure that C++ is portable; that code you write for Microsoft\u0026rsquo;s compiler will compile without errors, using a compiler on a Mac, UNIX, a Windows box, or an Alpha.\nThe ANSI standard has been stable for a while, and all the major C++ compiler manufacturers support the ANSI standard.\nLearning C++ The most important thing while learning C++ is to focus on concepts.\nThe purpose of learning a programming language is to become a better programmer; that is, to become more effective at designing and implementing new systems and at maintaining old ones.\nC++ supports a variety of programming styles. You can write in the style of Fortran, C, Smalltalk, etc., in any language. Each style can achieve its aims effectively while maintaining runtime and space efficiency.\nEnvironment Setup Installing GNU C/C++ Compiler UNIX/Linux Installation If you are using Linux or UNIX then check whether GCC is installed on your system by entering the following command from the command line\n$ g++ -v If you have installed GCC, then it should print a message such as the following\nApple clang version 13.1.6 (clang-1316.0.21.2) Target: arm64-apple-darwin21.4.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin if GCC is not installed, then you will have to install it yourself using the detailed instructions available at https://gcc.gnu.org/install/.\nWindows Installation To install GCC at Windows you need to install MinGW. To install MinGW, goto the MinGW homepage, http://www.mingw.org/, and follow the link to the MinGW download page. Download the latest version of the MinGW installation program which should be named MinGW-\u0026lt;version\u0026gt;.exe.\nWhile installing MinGW, at a minimum, you must install gcc-core, gcc-g++, binutils, and the MinGW runtime, but you may wish to install more.\nAdd the bin subdirectory of your MinGW installation to your PATH environment variable so that you can specify these tools on the command line by their simple names.\nWhen the installation is complete, you will be able to run gcc, g++, ar, ranlib, dlltool, and several other GNU tools from the Windows command line.\nBasic Syntax When we consider a C++ program, it can be defined as a collection of object that communicate via invoking each other\u0026rsquo;s methods. Let us now briefly look into what a class, object, methods, and instant variables mean.\n  Class: A class can be defined as a template/blueprint that describes the behaviors/states that object of its type support.\n  Object: Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors - wagging, barking, eating. An object is an instance of a class.\n  Methods - A method is basically a behavior. A calss can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.\n  Instance Variables: Each object has its unique set of instance variables. An object\u0026rsquo;s state is created by the values assigned to these instance variable.\n  C++ Program Structure Let us look at a simple code that would print the words Hello World.\n#include \u0026lt;iostream\u0026gt;using namespace std; // main() is where program execution begins. int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; // prints Hello World  return 0; } Let us look at the various parts of the above program\n  The C++ language defines several headers, which contain information that is either necessary or useful to your program. For this program, the header  is needed.\n  The line using namespace std; tells the compiler to use the std namespace. Namespaces are a relatively recent addition to C++.\n  The next line '// main() is where program execution begins. is a single-line comment available in C++. Single-line comments begin with // and stop at the end of the line.\n  The line int main() is the main function where program execution begins.\n  The next line cout \u0026laquo; \u0026ldquo;Hello World\u0026rdquo;; causes the message \u0026ldquo;Hello World\u0026rdquo; to be displayed on the screen.\n  The next line return 0; terminates main() function and causes it to return the value 0 to the calling process.\n  ","permalink":"https://guangchen811.github.io/languagetutorial/cpp/","summary":"Source: tutorials point\nUseful Links: www.cplusplus.com\nC++ is a middle-level programming language developed by Bjarne Stroustrup starting in 1979 at Bell Labs. C++ runs on a variety of platforms, such as Windows, Mac OS, and the various versions of UNIX. This C++ tutorial adopts a simple and practical approach to describe the concepts of C++ for beginners to advanded software engineers.\nWhy to Learn C++ C++ is a MUST for students and working professionals to become a great Software Engineer.","title":"C++ Tutorial"},{"content":"Description Given an array of positive integers nums and a positive integer target return the minimal legth of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nIntuition We could keep 2 pointer, one for the start and the other for the end of current subarray, and make optimal moves so as to keep the sum greater than s as well as maintain the lowest size possible.\nAlgorithm Code class Solution { public: int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int ans = INT_MAX; int left = 0; int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; while (sum \u0026gt;= target) { ans = min(ans, i + 1 -left); sum -= nums[left++]; } } return (ans != INT_MAX) ? ans : 0; } }; Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/minimum-size-subarray-sum/","summary":"No.209","title":"Minimum Size Subarray Sum"},{"content":"Description Given the root of a binary search tree, rearrange the tree in in-order so that the left most node in the tree is now the root of the tree, and every node has no left child and only one right child.\nIntuition If root.left is not None, make root.left as root and root.left.right as root.left recursively.\nAlgorithm Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def increasingBST(self, root: TreeNode) -\u0026gt; TreeNode: if root == None: return None if root.left == None: root.right = self.increasingBST(root.right) return root node = root.left root.left = node.right node.right = root return self.increasingBST(node) Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/increasing-order-search-tree/","summary":"No.897","title":"Increasing Order Search Tree"},{"content":"Description Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nIntuition Visit nodes according to the value from largest to smallest. Maintain a global variable SUM.\nAlgorithm Pseudocode  Initial a global variable SUM.\nVisit root node using the follow function:\n  If root is Null, return.\nvisit root.right.\nSUM += root.val.\nroot.val = SUM.\nvisit root.left.\n Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: self.SUM = 0 self.visit(root) return root def visit(self, root): if root == None: return self.visit(root.right) self.SUM += root.val root.val = self.SUM self.visit(root.left) Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/convert-bst-to-greater-tree/","summary":"No.538","title":"Convert BST to Greater Tree"},{"content":"Description Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\nIntuition We can replace odds with 1 and evens with o, and then generate a list cur_odd. cur_odd[i] is equal to the number of odds until i. Now, we just need to count the number of pairs in cur_odd which difference is equal to k.\nAlgorithm In fact, it\u0026rsquo;s not necessary to build cur_odd explicitly. A hash map can make things easier.\nPseudocode  Initial a map as {0:1}.\nInitial current odd numbers as 0.\nInitial answer as 0.\nFor each number in numbers.\n If the number is a odd\n Let cur_odd add one.\n Else, if current odd numbers - k in the map.\n Let the answer add map[current odd numbers - k] Else, if current odd numbers not in the map.\n  Set map[current odd numbers] as 0.\n Let map[current odd numbers] add one.\n return the answer.\n Code class Solution: def numberOfSubarrays(self, nums: List[int], k: int) -\u0026gt; int: mp = {0:1} cur_odd = 0 ans = 0 for num in nums: if num % 2 == 1: cur_odd += 1 if cur_odd-k in mp: ans += mp[cur_odd-k] if not cur_odd in mp: mp[cur_odd] = 0 mp[cur_odd] += 1 return ans Complexity Analysis  Time Complexity: $O(n)$ Space Complexity: $O(n)$  ","permalink":"https://guangchen811.github.io/leetcode/count-number-of-nice-subarrays/","summary":"No.1248","title":"Count Number of Nice Subarrays"},{"content":"Description You are given two strings s1 and s2 of equal length consisting of letters \u0026quot;x\u0026quot; and \u0026quot;y\u0026quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].\nReturn the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.\nIntuition Given a index i, there are totally 4 possiblilities of s1[i] and s2[i]: x-x,y-y,x-yandy-x. x-x and y-y have been matched, we just need to process two other situations.\nAlgorithm Assum there are a pairs of x-y and b pairs of y-x. For 2 pairs of x-y or y-x, we can swap 1 steps to make them matching: \u0026quot;xx\u0026quot;|\u0026quot;yy\u0026quot;$\\rightarrow$\u0026quot;xy\u0026quot;|\u0026quot;xy\u0026quot;. For one x-y and one y-x, we need 2 steps: \u0026quot;xy\u0026quot;|\u0026quot;yx\u0026quot;$\\rightarrow$\u0026quot;xx\u0026quot;|\u0026quot;yy\u0026quot;$\\rightarrow$\u0026quot;xy\u0026quot;|\u0026quot;xy\u0026quot;.\nSo, if a and b are both even. We just need $\\frac{a+b}{2}$ steps without other process.\nIf one of a and b is even and the other is odd, we can\u0026rsquo;t make it match any way.\nIf their are both odd, we need $\\frac{a+b-2}{2}+2=\\frac{a+b}{2}+1$ steps.\nPseudocode  Read s1 and s2 to get a and b.\nIf only one of a and b is even, return -1.\nElse if both a and b are even, return $\\frac{a+b}{2}$.\nElse return $\\frac{a+b}{2}+1$\n Code class Solution: def minimumSwap(self, s1: str, s2: str) -\u0026gt; int: a = 0 b = 0 for i in range(len(s1)): if s1[i] == \u0026#39;x\u0026#39; and s2[i] == \u0026#39;y\u0026#39;: a += 1 elif s1[i] == \u0026#39;y\u0026#39; and s2[i] == \u0026#39;x\u0026#39;: b += 1 if a%2==0 and b%2==0: return int((a+b)/2) elif a%2==1 and b%2==1: return int((a+b)/2+1) else: return -1 Complexity Analysis  Time Complexity: $O(n)$. Space Complexity: $O(1)$.  ","permalink":"https://guangchen811.github.io/leetcode/minimum-swaps-to-make-strings-equal/","summary":"No.1247","title":"Minimum Swaps to Make Strings Equal"},{"content":"Description You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node\u0026rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nIntuition There are only two possibilities when we searching a node:\n node is equal to the value node is not equal to the value  Algorithm When the node is equal to the value, we just need to return it. Otherwise, we just need to visit its left or right child recursively.\nPseudocode  visit root node.\n If root is null or root\u0026rsquo;s value is equal to target value, return the root.\nOtherwises, if root\u0026rsquo;s value is bigger than target value.\n visit root\u0026rsquo;s left child.\n Otherwises\n visit root\u0026rsquo;s right child.\n   Code # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def searchBST(self, root: Optional[TreeNode], val: int) -\u0026gt; Optional[TreeNode]: if (root == None or root.val == val): return root elif root.val \u0026lt; val: return self.searchBST(root.right, val) else: return self.searchBST(root.left, val) Complexity Analysis  Time Complexity: $O(\\log{n})$ Space Complexity: $O(1)$  ","permalink":"https://guangchen811.github.io/leetcode/searchinabinarysearchtree/","summary":"No.700","title":"Search in a Binary Seaerch Tree"},{"content":"Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nIntuition Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\nAlgorithm Just like how we would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of $l1$ and $l2$. Since each digit is in the range of 0\u0026hellip;9, summing two digits may \u0026ldquo;overflow\u0026rdquo;. For example $5+7=12$. In this case, we set the current digit to 2 and bring over the $carry=1$ to the next iteration. $carry$ must be either $0$ or $1$ because the largest possible sum of two digits (including the carry) is $9+9+1=19$.\nPseudocode  Initialize current node to dummy head of the returning list.\nInitialize $carry$ to 0.\nInitialize $p$ and $q$ to head of $l1$ and $l2$ respectively. Loop through lists $l1$ and $l2$ until you reach both ends.\n Set $x$ to node $p$\u0026rsquo;s value. If $p$ has reached the end of $l1$, set to 0.\nSet $y$ to node $q$\u0026rsquo;s value. If $q$ has reached the end of $l2$, set to 0.\nSet $sum=x+y+carry$.\nUpdate $carry = sum/10$\nCreate a new node with teh digit value of ($sum\\mod{10}$) and set it to current node\u0026rsquo;s next, then advance current node to next.\nAdvance both $p$ and $q$.\n Check if $carry=1$, if so append a new node with digit 1 to the returning list.\nReturn dummy head\u0026rsquo;s next node.\n Code # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummyHead = ListNode(val=0) p = l1 q = l2 curr = dummyHead carry = 0 while(p != None or q != None): if p != None: x = p.val else: x = 0 if q != None: y = q.val else: y = 0 sum = carry + x + y carry = sum // 10 curr.next = ListNode(val=sum % 10) curr = curr.next if(p != None): p = p.next if(q != None): q = q.next if (carry \u0026gt; 0): curr.next = ListNode(carry) return dummyHead.next Complexity Analysis   Time Complexity: $O(\\max{(m,n)})$. Assume that $m$ and $n$ represents the length of $l1$ and $l2$ respectively, the algorithm above iterates at most $\\max{(m,n)}$ times.\n  Space Complexity: $O(\\max{(m,n)})$. The length of the new list is at most $\\max{(m,n)}+1$.\n  ","permalink":"https://guangchen811.github.io/leetcode/add-two-numbers/","summary":"No.2","title":"Add Two Numbers"}]