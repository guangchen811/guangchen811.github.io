---
title: "Go Modules Reference中文翻译"
date: 2022-09-03T16:20:27+08:00
draft: False
summary: No.2
ismath: true
tags:
- go
categories:
- go
---
[source](https://go.dev/ref/mod#vcs-find)
## 介绍
模块是Go语言管理依赖的方式. 

这篇文档详细地说明了Go语言的模块系统. 关于如何创建Go项目，可以参看[如何写Go语言程序](https://go.dev/doc/code.html). 关于使用模块、将项目迁移到模块，和其他相关的话题，请参看从[使用Go模块](https://blog.golang.org/using-go-modules)开始的系列博客.
## 模块、包和版本
模块是统一发布、版本控制和分发的包的集合. 我们可以直接从版本控制仓库中下载模块，也可以从一些模块代理服务器下载.

一个模块可以由go.mod文件中标明的[模块路径](https://go.dev/ref/mod#glos-module-path)来识别. 除模块路径外，go.mod 文件中还包含了模块间依赖的信息.模块的根目录为包含go.mod文件的路径. 主模块是指包含go命令被调用的目录的模块.

模块中的每一个包是指在相同路径下、一同被编译的源文件的集合. 一个包路径是由模块路径和包含包的子目录(指从模块根目录出发的相对路径)拼接而成的. 例如，模块"golang.org/x/net"的"html"路径中包含的包的路径为"golang.org/x/net/html".

### 模块路径
模块路径是指一个模块的标准名称，他会在go.mod文件中使用mod指令声明. 如上文所述，模块路径是模块内包路径的前缀. 

一个模块路径既要指明模块的功能，也要指明我们可以在哪里找到它。一般来说，模块路径会包含仓库根路径、仓库中文件夹的路径(一般为空，这是仓库的根目录就是模块的根路径)，以及一个主版本号后缀(只针对主版本号大于等于2时)。

- 仓库根路径是模块路径中对应版本控制仓库根路径的部分. 大多数模块都定义在其仓库的根路径上。例如仓库根路径`golang.org/x/net`就是与其同名的模块的根路径。关于go命令如何使用HTTP协议从模块中定位一个仓库请参阅[从模块路径中找到仓库](https://go.dev/ref/mod#vcs-find). 
- 如果模块没有被定义在仓库的根目录，模块子目录就是模块名称中指明模块在仓库中地址的部分。模块子目录也可以作为前缀指明版本，如模块`golang.org/x/tools/gopls`就是根路径为`golang.org/x/tools/gopls`的仓库中的`gopls`子目录。参看，[将版本映射为提交](https://go.dev/ref/mod#vcs-version)和[仓库中的模块路径](https://go.dev/ref/mod#vcs-dir).
- 在发布主版本号大于等于2的模块时，模块路径必须以[主版本后缀](https://go.dev/ref/mod#major-version-suffixes)，如`/v2`结尾。他也可以作为子目录的一部分。例如，路径为`golang.org/x/repo/sub/v2`的模块可能在仓库`golang.org/x/repo`的`/sub`路径中，也可能在`/sub/v2`路径中.

如果一个模块可能被其他模块依赖，我们只有在遵守上述规则的情况下，go命令才能正确的找到并下载该模块。此外，模块路径中的字符还有一些[词法限制](https://go.dev/ref/mod#go-mod-file-ident)。

### 版本(version)
版本号表明了模块的一个不可变快照，它可以是发布版或预发布版。每个版本都以字母
v开头，随后是可读的版本信息。有关如何格式化、解释和比较版本的详细信息，请参阅[语义版本 2.0.0](https://semver.org/spec/v2.0.0.html)

总的来说，一个语义版本包含三个由`.`分割的非负整数(从左到右分别标识主要版本号、次要版本号和布丁版本号). 补丁版本后面可以跟一个以连字符开头的可选预发布字符串。 预发布字符串或补丁版本后面可以跟以加号开头的构建元数据字符串。 例如，v0.0.0、v1.12.134、v8.0.5-pre 和 v2.0.9+meta 都是有效版本。

版本的每个部分都表示版本是否稳定以及是否与以前的版本兼容。

- 当一个向后不兼容的改变发生时（如一个包被删除时），主要版本号必须加一，次要版本号和补丁版本号需要置为0. 
- 当一个向后兼容的改变发生时（如增加了一个新的函数），次要版本号需要加一，补丁号需要置为0.
- 当发生了对模块的对外接口没有变化的改动时（如修复了一个bug或者进行了代码优化），补丁号需要加1.
- `pre-release`后缀用于标注预发行版. 预发行版通常先于发行版发布. 例如，v1.2.3-pre要早于v1.2.3.
- 为了进行版本比较，构建元数据（build metadata）后缀会被忽略. 标有构建元数据的版本会被版本控制仓库忽略，但是构建元数据会被保留在`go.mod`文件指定的版本中。后缀`+incompatible`表示发布在迁移到模块主版本号大于等于2的版本之前发行的版本.

如果一个版本的主版本为0或者带有pre后缀，那么该版本是不稳定的. 例如`v0.2.0`可能并不兼容`v0.1.0`, `v1.5.0-beta`可能不兼容`v1.5.0`.

Go语言可以通过使用标签、分支和版本重命名来访问不符合上述命名规范的模块. 然而，在主模块中，go命令会自动把不符合标准的名字转换为标准版本号. go命令还会自动删掉构建元数据后缀（除+incompatible之外）。这会导致产生伪版本(pseudo-version)：指一个编码了版本标识或者时间戳的预发行版. 例如`go get -d golang.org/x/net@daa7c041`将会被转换为`v0.0.0-20191109021931-daa7c04131f4`. 标准版本被要求放在主模块外。此外，如果非标准的版本如`master`出现在go.mod文件中，go命令会报错.

### 伪版本

一个伪版本特指用于在版本控制仓库中编码特别版本信息的预发行版本. 例如`v0.0.0-20191109021931-daa7c04131f5`就是一个伪版本.

伪版本可能用于重命名没有语义版本标签的版本. 主要出现在创建版本标签前的测试提交，如在开发分支中的提交.

每一个伪版本号由三部分组成：
- 一个基本版本前缀(vX.0.0或X.Y.Z-0)，可以来自于修订前的语义版本标签，如果没有的话就定为`vX.0.0`.
- 时间戳(yyyymmddhhmmss),指创建该版本时的世界标准时间(UTC). 在Git中表示提交时间而非创作时间.
- 一个修订标识符(abcdefabcdef)，为提交哈希的12位前缀. 如果是子版本，则为12个0.

由于基本版本号的不同，伪版本号可能为以下三种形式之一. 这确保了伪版本号一定高于基本版本号，但低于下一个有标签的版本号.

-`vX.0.0-yyyymmddhhmmss-abcdefabcdef`被用于基本版本号未知的情况. 与所有版本一样，主版本号必须匹配模块的主版本后缀.
-`vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef`被用于基本版本号为`vX.Y.Z-pre`的情形.
-`vX.Y.(Z+1).0.yyyymmddhhmmss-abcdefabcdef`被用于主版本号为`vX.Y.Z`的情况. 例如，如果基本版本号为`v1.2.3`，伪版本号可能是`v1.2.4-0.20191109021931-daa7c04131f5`.

通过使用不同的基本版本号，多个伪版本号可能指向同一次提交. 这种情况在一个低版本在伪版本产生后被打上新标签时会自然的发生。

这种形式为伪版本提供了两个有用的特性：
- 具有已知基本版本号的伪版本排序高于基本版本但低于其他预发行版本.
- 基于相同版本的伪版本按时间排序.

go命令会执行以下操作来确保模块作者可以控制伪版本如何与其他版本比较，伪版本是指模块提交历史中的一部分的版本.

- 如果一个基本版本已被指明，那么必须存在一个对应的语义版本标签作为伪版本描述的版本的祖先. 这可以避免开发者绕开最小版本号选择原则，使用一个比所有版本都高的版本，如`v1.999.999-99999999999999-daa7c04131f5`.
- 时间戳必须匹配重命名版本的时间戳. 这是为了防止攻击者使用相很多相同版本号淹没模块代理. 同时也防止了模块使用者修改版本的相对顺序.
- 修订版必须是模块仓库中分支或标签之一的祖先. 这是为了防止攻击者引用未经允许的修改或拉取请求.

伪版本不需要手动输入. 许多命令都会接受提交哈希或者分支名称，并将其自动转化为伪版本号。例如:
```bash
go get -d example.com/mod@master
go list -m -json example.com/mod@abcd1234
```

### Major version suffixes

