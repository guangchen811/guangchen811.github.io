---
title: "Go Modules Reference中文翻译"
date: 2022-09-03T16:20:27+08:00
draft: False
summary: No.2
ismath: true
tags:
- go
categories:
- go
---
[source](https://go.dev/ref/mod#vcs-find)
## 介绍
模块是Go语言管理依赖的方式. 

这篇文档详细地说明了Go语言的模块系统. 关于如何创建Go项目，可以参看[如何写Go语言程序](https://go.dev/doc/code.html). 关于使用模块、将项目迁移到模块，和其他相关的话题，请参看从[使用Go模块](https://blog.golang.org/using-go-modules)开始的系列博客.
## 模块、包和版本
模块是统一发布、版本控制和分发的包的集合. 我们可以直接从版本控制仓库中下载模块，也可以从一些模块代理服务器下载.

一个模块可以由go.mod文件中标明的[模块路径](https://go.dev/ref/mod#glos-module-path)来识别. 除模块路径外，go.mod 文件中还包含了模块间依赖的信息.模块的根目录为包含go.mod文件的路径. 主模块是指包含go命令被调用的目录的模块.

模块中的每一个包是指在相同路径下、一同被编译的源文件的集合. 一个包路径是由模块路径和包含包的子目录(指从模块根目录出发的相对路径)拼接而成的. 例如，模块"golang.org/x/net"的"html"路径中包含的包的路径为"golang.org/x/net/html".

### 模块路径
模块路径是指一个模块的标准名称，他会在go.mod文件中使用mod指令声明. 如上文所述，模块路径是模块内包路径的前缀. 

一个模块路径既要指明模块的功能，也要指明我们可以在哪里找到它。一般来说，模块路径会包含仓库根路径、仓库中文件夹的路径(一般为空，这是仓库的根目录就是模块的根路径)，以及一个主版本号后缀(只针对主版本号大于等于2时)。

- 仓库根路径是模块路径中对应版本控制仓库根路径的部分. 大多数模块都定义在其仓库的根路径上。例如仓库根路径`golang.org/x/net`就是与其同名的模块的根路径。关于go命令如何使用HTTP协议从模块中定位一个仓库请参阅[从模块路径中找到仓库](https://go.dev/ref/mod#vcs-find). 
- 如果模块没有被定义在仓库的根目录，模块子目录就是模块名称中指明模块在仓库中地址的部分。模块子目录也可以作为前缀指明版本，如模块`golang.org/x/tools/gopls`就是根路径为`golang.org/x/tools/gopls`的仓库中的`gopls`子目录。参看，[将版本映射为提交](https://go.dev/ref/mod#vcs-version)和[仓库中的模块路径](https://go.dev/ref/mod#vcs-dir).
- 在发布主版本号大于等于2的模块时，模块路径必须以[主版本后缀](https://go.dev/ref/mod#major-version-suffixes)，如`/v2`结尾。他也可以作为子目录的一部分。例如，路径为`golang.org/x/repo/sub/v2`的模块可能在仓库`golang.org/x/repo`的`/sub`路径中，也可能在`/sub/v2`路径中.

如果一个模块可能被其他模块依赖，我们只有在遵守上述规则的情况下，go命令才能正确的找到并下载该模块。此外，模块路径中的字符还有一些[词法限制](https://go.dev/ref/mod#go-mod-file-ident)。

### 版本(version)
版本号表明了模块的一个不可变快照，它可以是发布版或预发布版。每个版本都以字母
v开头，随后是可读的版本信息。有关如何格式化、解释和比较版本的详细信息，请参阅[语义版本 2.0.0](https://semver.org/spec/v2.0.0.html)

总的来说，一个语义版本包含三个由`.`分割的非负整数(从左到右分别标识主要版本号、次要版本号和布丁版本号). 补丁版本后面可以跟一个以连字符开头的可选预发布字符串。 预发布字符串或补丁版本后面可以跟以加号开头的构建元数据字符串。 例如，v0.0.0、v1.12.134、v8.0.5-pre 和 v2.0.9+meta 都是有效版本。

版本的每个部分都表示版本是否稳定以及是否与以前的版本兼容。

- 当一个向后不兼容的改变发生时（如一个包被删除时），主要版本号必须加一，次要版本号和补丁版本号需要置为0. 
- 当一个向后兼容的改变发生时（如增加了一个新的函数），次要版本号需要加一，补丁号需要置为0.
- 当发生了对模块的对外接口没有变化的改动时（如修复了一个bug或者进行了代码优化），补丁号需要加1.
- `pre-release`后缀用于标注预发行版. 预发行版通常先于发行版发布. 例如，v1.2.3-pre要早于v1.2.3.
- 为了进行版本比较，构建元数据（build metadata）后缀会被忽略. 标有构建元数据的版本会被版本控制仓库忽略，但是构建元数据会被保留在`go.mod`文件指定的版本中。后缀`+incompatible`表示发布在迁移到模块主版本号大于等于2的版本之前发行的版本.

如果一个版本的主版本为0或者带有pre后缀，那么该版本是不稳定的. 例如`v0.2.0`可能并不兼容`v0.1.0`, `v1.5.0-beta`可能不兼容`v1.5.0`.

Go语言可以通过使用标签、分支和版本重命名来访问不符合上述命名规范的模块. 然而，在主模块中，go命令会自动把不符合标准的名字转换为标准版本号. go命令还会自动删掉构建元数据后缀（除+incompatible之外）。这会导致产生伪版本(pseudo-version)：指一个编码了版本标识或者时间戳的预发行版. 例如`go get -d golang.org/x/net@daa7c041`将会被转换为`v0.0.0-20191109021931-daa7c04131f4`. 标准版本被要求放在主模块外。此外，如果非标准的版本如`master`出现在go.mod文件中，go命令会报错.

### 伪版本

一个伪版本特指用于在版本控制仓库中编码特别版本信息的预发行版本. 例如`v0.0.0-20191109021931-daa7c04131f5`就是一个伪版本.

伪版本可能用于重命名没有语义版本标签的版本. 主要出现在创建版本标签前的测试提交，如在开发分支中的提交.

每一个伪版本号由三部分组成：
- 一个基本版本前缀(vX.0.0或X.Y.Z-0)，可以来自于修订前的语义版本标签，如果没有的话就定为`vX.0.0`.
- 时间戳(yyyymmddhhmmss),指创建该版本时的世界标准时间(UTC). 在Git中表示提交时间而非创作时间.
- 一个修订标识符(abcdefabcdef)，为提交哈希的12位前缀. 如果是子版本，则为12个0.

由于基本版本号的不同，伪版本号可能为以下三种形式之一. 这确保了伪版本号一定高于基本版本号，但低于下一个有标签的版本号.

-`vX.0.0-yyyymmddhhmmss-abcdefabcdef`被用于基本版本号未知的情况. 与所有版本一样，主版本号必须匹配模块的主版本后缀.
-`vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef`被用于基本版本号为`vX.Y.Z-pre`的情形.
-`vX.Y.(Z+1).0.yyyymmddhhmmss-abcdefabcdef`被用于主版本号为`vX.Y.Z`的情况. 例如，如果基本版本号为`v1.2.3`，伪版本号可能是`v1.2.4-0.20191109021931-daa7c04131f5`.

通过使用不同的基本版本号，多个伪版本号可能指向同一次提交. 这种情况在一个低版本在伪版本产生后被打上新标签时会自然的发生。

这种形式为伪版本提供了两个有用的特性：
- 具有已知基本版本号的伪版本排序高于基本版本但低于其他预发行版本.
- 基于相同版本的伪版本按时间排序.

go命令会执行以下操作来确保模块作者可以控制伪版本如何与其他版本比较，伪版本是指模块提交历史中的一部分的版本.

- 如果一个基本版本已被指明，那么必须存在一个对应的语义版本标签作为伪版本描述的版本的祖先. 这可以避免开发者绕开最小版本号选择原则，使用一个比所有版本都高的版本，如`v1.999.999-99999999999999-daa7c04131f5`.
- 时间戳必须匹配重命名版本的时间戳. 这是为了防止攻击者使用相很多相同版本号淹没模块代理. 同时也防止了模块使用者修改版本的相对顺序.
- 修订版必须是模块仓库中分支或标签之一的祖先. 这是为了防止攻击者引用未经允许的修改或拉取请求.

伪版本不需要手动输入. 许多命令都会接受提交哈希或者分支名称，并将其自动转化为伪版本号。例如:
```bash
go get -d example.com/mod@master
go list -m -json example.com/mod@abcd1234
```

### 主版本后缀
从主版本2开始，模块路径必须有一个主版本号前缀如`/v2`来匹配主版本号。例如，一个模块可以将v1.0.0存在`example.com/mod`路径下，那么它必须在`example.com/mod/v2`路径存储其v2.0.0版本.

主版本号后缀需要实现导入[兼容性原则](https://research.swtch.com/vgo-import)：
- 如果一个旧的包和新的包有相同的引用路径，新的包必须向后兼容旧的包。

根据定义，模块新主要版本中的软件包与之前主要版本的相应软件包不向后兼容。因此，从v2开始，软件包需要新的导入路径。这是通过在模块路径中添加一个主要版本后缀来实现的。由于模块路径是模块中每个软件包导入路径的前缀，因此在模块路径中添加主要版本后缀为每个不兼容的版本提供了独特的导入路径。

主要版本v0或v1不允许使用主要版本后缀。无需在v0和v1之间更改模块路径，因为v0版本不稳定，并且没有兼容性保证。此外，对于大多数模块，v1与最后一个v0版本向后兼容；v1版本是对兼容性的承诺，而不是与v0相比不兼容的更改。

特别的是，从`gopkg.in/`开始的模块必须有主版本后缀，即使是`v0`和`v1`. 后缀必须以`.`或者`-`开始.

主版本后缀使得一个模块的多个主版本可以共存在同一次build中. 这在解决[钻石依赖问题](https://research.swtch.com/vgo-import#dependency_story)时是必要的. 通常，如果传递依赖项需要两个不同版本的模块，则将使用更高的版本. 然而，如果两个版本不兼容，那么两个版本都不能满足所有客户端. 因为不兼容的版本一定有着不同的版本号，因此其对应的模块路径也不同. 这就解决了冲突：具有不同后缀的模块会被视为单独的模块，即便对于其模块根目录的同一子目录中的软件包，这两个模块也是不同的.

许多Go项目在迁移成模块之前（可能是由于go module还没有被推出）在没有使用主要版本后缀的情况下发布了v2或更高版本的版本. 这些版本会带有`+incompatible`标签. 更多信息参见[非模块仓库的兼容性](https://go.dev/ref/mod#non-module-compat)

### 将包解析成模块

go命令使用[包路径](#术语表)来加载一个具体的包时需要确定哪个模块提供了这个包.

go命令会从[构建列表](#术语表)中搜索包对应的路径中包含的模块. 例如，如果引入了包`example.com/a/b`，而`example.com/a`在构建列表之中，go命令会检查`example.com/a`的目录`b`中是否包含这个包. 目录中必须至少包含一个以`.go`作为后缀的文件. [构建依赖](https://go.dev/pkg/go/build/#hdr-Build_Constraints)不被用于该目的. 如果构建列表中的确存在一个模块提供了这个包就会应用这个模块. 如果没有模块提供这个包或者两个/多个模块提供了这个包，go命令会报错. `-mod=mod`命令行flag会尝试寻找新的提供丢失包的模块，并更新`go.mod`和`go.sum`.`go get`和`go mod tidy`会自动这样做.

当go命令在包路径中查找新的模块时，他会检查`GOPROXY`环境变量（一个由逗号分割的代理URL地址列表或是关键词`direct`或`off`).代理URL指明go命令需要使用GOPROXY协议连接一个模块代理。 `direct`指明go命令应该直接连接一个版本控制系统. `off`指明不需要尝试通信. `GOPRIVATE`和`GONOPROXY`可以用于控制这些行为.

对于GOPROXY列表中的每个条目，go命令请求可能提供软件包的每个模块路径的最新版本（即软件包路径的每个前缀）。对于每个成功请求的模块路径，go命令将以最新版本下载模块，并检查模块是否包含请求的软件包。如果一个或多个模块包含请求的软件包，则使用路径最长的模块。如果找到一个或多个模块，但没有一个模块包含请求的软件包，则会报告错误。如果没有找到模块，go命令将尝试GOPROXY列表中的下一个条目。如果没有留下任何条目，则会报告错误。

例如，假设go命令在寻找名为`golang.org/x/net/html`的软件包，而`GOPROXY`被设定为`https://copr.example.com,https://proxy.golang.org`. go命令会尝试如下请求:

- 对`https://corp.example.com/(并列):
    - 请求最新版本的`golang.org/x/net/html`
    - 请求最新版本的`golang.org/x/net`
    - 请求最新版本的`golang.org/x`
    - 请求最新版本的`golang.org`
- 如果上述请求404或410，对`https://proxy.golang.org/`：
    - 请求最新版本的`golang.org/x/net/html`
    - 请求最新版本的`golang.org/x/net`
    - 请求最新版本的`golang.org/x`
    - 请求最新版本的`golang.org`

在合适的模块被找到之后，go命令会在主模块`go.mod`文件中添加一个新的包含模块路径和版本的requirement.这确保了将来加载相同的软件包时，同一模块将在同一版本中使用. 如果已解决的软件包不是由主模块中的软件包导入的，则新需求将有一个`//`间接注释.

### 最小版本选择


### 术语表

- 包路径: 唯一标识一个包的路径. 包路径由模块路径和模块中的子目录拼接而成. 例如`"golang.org/x/net/html"`在`"golang.org/x/net"`模块中的`"html"`子路径中. 包路径是引用路径的同义词

- 引用路径：用于在Go源文件中引用一个包的字符串. 是包路径的同义词.

- 构建列表(build list): 包含模块版本信息的表，会被用于`go build`, `go list`或`go test`中. 构建列表遵循[最小版本选择(minimal version selection)](#术语表)，由主模块的go.mod文件和传递必需模块中的go.mod文件确定. 构建列表包含[module graph](#术语表)中需要的所有模块的各个版本，而非与哪一个特定go命令相关。

- 模块图(module graph)：模块依赖关系对应的有向图，位于[主模块](#术语表); 图中的每一条边都是`go.mod`文件中`require`语句说明的版本(或go.mod文件中的`replace`和`exclude`语句).

- 主模块(main module)：go命令被调用的模块. 主模块被当前目录或当前目录的父目录中的`go.mod`文件定义. 参见[模块、包和版本](#模块、包和版本).

- 最小版本选择(minimal version selection, MVS)：用于确定所有在构建中需要的模块版本的算法. 具体参见[最小版本选择章节](#最小版本选择).